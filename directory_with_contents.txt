P2P_Distributed_System
└── P2P_Distributed_System
│   ├── .gitignore
│   └── .vscode
│   │   ├── c_cpp_properties.json
│       ├── settings.json
│   ├── CMakeLists.txt
│   ├── LICENSE
│   ├── README.md
│   ├── build.sh
│   └── client_ui
│   ├── command.md
│   └── config
│   │   ├── development_config.json
│   │   ├── production_config.json
│       ├── staging_config.json
│   └── db
│   │   └── mongodb
│   │   │   └── files
│   │   │   │   ├── create_collection.js
│   │   │   │   ├── migration_1.js
│   │   │       ├── seed_data.js
│   │       └── users
│   │       │   ├── create_collection.js
│   │       │   ├── migration_1.js
│   │           ├── seed_data.js
│       └── postgresql
│       │   └── files
│       │   │   ├── create_table.sql
│       │   │   ├── migration_1.sql
│       │       ├── seed_data.sql
│           └── users
│           │   ├── create_table.sql
│           │   ├── migration_1.sql
│               ├── seed_data.sql
│   └── docs
│       ├── architecture.md
│   └── env
│   │   ├── .env.development
│   │   ├── .env.production
│       ├── .env.staging
│   └── include
│   │   ├── api.h
│   │   ├── database.h
│   │   ├── file_transfer.h
│   │   ├── middleware.h
│   │   ├── networking.h
│       ├── security.h
│   ├── index.html
│   └── lib
│   │   └── common
│       └── macos
│   └── scripts
│   │   ├── build_macos.sh
│   │   ├── common_build.sh
│       ├── deploy_macos.sh
│   └── src
│   │   └── api
│   │       └── v1
│   │           └── file
│   │           │   ├── delete_file.h
│   │           │   ├── download_file.h
│   │           │   ├── file_metadata.h
│   │               ├── upload_file.h
│   │   └── client
│   │   │   ├── cli_interface.cpp
│   │   │   ├── client_config_manager.cpp
│   │   │   ├── client_file_manager.cpp
│   │   │   ├── client_sync_manager.cpp
│   │       ├── peer_connection_manager.cpp
│   │   ├── config_manager.h
│   │   └── database
│   │   │   ├── database_manager.cpp
│   │   │   ├── mongodb_database.h
│   │       ├── postgresql_database.h
│   │   └── file_transfer
│   │   │   ├── file_assembler.h
│   │   │   ├── file_chunk_manager.h
│   │   │   ├── file_splitter.h
│   │   │   ├── file_transfer_manager.cpp
│   │       ├── file_verifier.h
│   │   ├── main.cpp
│   │   └── middleware
│   │   │   ├── auth_middleware.h
│   │   │   ├── logging_middleware.h
│   │   │   ├── rate_limiter.h
│   │       ├── request_validation.h
│   │   └── networking
│   │   │   ├── network_manager.cpp
│   │   │   ├── peer_discovery.h
│   │   │   ├── peer_tracker.cpp
│   │   │   ├── tcp_connection.h
│   │       ├── udp_connection.h
│   │   └── security
│   │   │   ├── decryption_handler.h
│   │   │   ├── encryption_handler.h
│   │       ├── key_management.cpp
│   │   └── serialization
│   │   │   ├── json_serialization.h
│   │   │   ├── protobuf_serialization.h
│   │       ├── serialization_manager.cpp
│   │   └── threads
│   │   │   ├── thread_manager.cpp
│   │   │   ├── thread_pool.h
│   │       ├── worker_threads.h
│       └── utils
│       │   ├── file_helpers.h
│       │   ├── log_helpers.h
│           ├── string_helpers.h
│   ├── test.cpp
│   ├── test.js
    └── tests
    │   ├── test_client.cpp
    │   ├── test_database.cpp
    │   ├── test_file_transfer.cpp
    │   ├── test_middleware.cpp
    │   ├── test_networking.cpp
        ├── test_security.cpp



File: .gitignore

/.vscode
/docs
/include
/scripts

/src/api
/src/client
/src/file_transfer
/src/middleware
/src/networking
/src/security
/src/serialization
/src/threads
/src/utils

/db

/tests

/build


File: c_cpp_properties.json

{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/include",
                "${workspaceFolder}/src",
                "/opt/homebrew/opt/libpqxx/include",
                "/opt/homebrew/include",
                "/opt/homebrew/opt/libpq/include"
            ],
            "defines": [],
            "macFrameworkPath": [
                "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks"
            ],
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "macos-clang-arm64",
            "compilerPath": "/usr/bin/clang++",
            "browse": {
                "path": [
                    "${workspaceFolder}/**",
                    "/opt/homebrew/opt/libpqxx/include",
                    "/opt/homebrew/include",
                    "/opt/homebrew/opt/libpq/include"
                ],
                "limitSymbolsToIncludedHeaders": true,
                "databaseFilename": ""
            }
        }
    ],
    "version": 4
}


File: settings.json

{
    "files.associations": {
        "fstream": "cpp"
    },
    "C_Cpp.errorSquiggles": "disabled"
}


File: CMakeLists.txt

cmake_minimum_required(VERSION 3.10)
project(P2PFileSharing)

set(CMAKE_CXX_STANDARD 17)

# Manually specify paths for libpqxx
set(PQXX_INCLUDE_DIR /opt/homebrew/opt/libpqxx/include)
set(PQXX_LIBRARY_DIR /opt/homebrew/opt/libpqxx/lib)

# Find the libpqxx library
find_library(PQXX_LIB pqxx PATHS ${PQXX_LIBRARY_DIR})

# Find nlohmann-json (installed via Homebrew)
find_package(nlohmann_json 3.2.0 REQUIRED)

# Add the executable and link libraries
add_executable(P2PFileSharing 
    src/main.cpp 
    src/config_manager.h  # Replace .h with the actual .cpp file
    src/database/postgresql_database.h  # Replace .h with the actual .cpp file
)

# Include directories for pqxx and nlohmann-json (nlohmann-json path for Homebrew)
target_include_directories(P2PFileSharing PRIVATE ${PQXX_INCLUDE_DIR} /opt/homebrew/include)

# Link the libraries (libpqxx and nlohmann-json)
target_link_libraries(P2PFileSharing PRIVATE ${PQXX_LIB} nlohmann_json::nlohmann_json)



File: LICENSE

MIT License

Copyright (c) 2024 Deepam Kumar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



File: README.md

# P2P-Distributed-Systems


It looks like your program successfully connects to the PostgreSQL database but exits right after the connection is established. This happens because, once the program executes all the instructions in `main()`, it reaches the end and exits automatically.

To keep the program running until it's manually terminated, you need to implement some logic that prevents the program from exiting immediately. This could be something like a loop, a server that listens for requests, or any other mechanism depending on the intended functionality of your application.

Here are a few approaches depending on the structure of your application:

### 1. **Basic Infinite Loop**:
You can add a simple infinite loop to keep the program running indefinitely until it's manually terminated (e.g., via `CTRL + C`).

```cpp
int main(int argc, char** argv) {
    // Load config and connect to the database
    std::string environment = "development";  // Default environment
    ConfigManager configManager;
    if (!configManager.loadConfig(environment)) {
        std::cerr << "Failed to load configuration for environment: " << environment << "\n";
        return 1;
    }

    std::cout << "Running in " << environment << " environment." << std::endl;

    PostgreSQLDatabase db(configManager.dbHost, configManager.dbPort, configManager.dbName, configManager.dbUser, configManager.dbPassword);
    if (!db.connect()) {
        std::cerr << "Failed to connect to PostgreSQL database\n";
        return 1;
    }
    std::cout << "Connected to PostgreSQL database successfully!\n";

    // Keep the program running
    while (true) {
        // Simulate program activity or add logic here
        std::this_thread::sleep_for(std::chrono::seconds(1));  // Sleep to prevent high CPU usage
    }

    return 0;
}
```

- The `while (true)` loop keeps the program running indefinitely. Inside the loop, we use `std::this_thread::sleep_for(std::chrono::seconds(1));` to simulate some delay (and to avoid busy-waiting, which consumes a lot of CPU).
- You can replace this with more meaningful logic as you build out your program.

### 2. **Event Loop**:
If your program is a server or client waiting for connections or input, you can replace the infinite loop with an event-driven loop. For example, if you have a command-line interface or network server, you could have a loop waiting for user input or network events.

```cpp
int main(int argc, char** argv) {
    // Load config and connect to the database
    std::string environment = "development";
    ConfigManager configManager;
    if (!configManager.loadConfig(environment)) {
        std::cerr << "Failed to load configuration for environment: " << environment << "\n";
        return 1;
    }

    std::cout << "Running in " << environment << " environment." << std::endl;

    PostgreSQLDatabase db(configManager.dbHost, configManager.dbPort, configManager.dbName, configManager.dbUser, configManager.dbPassword);
    if (!db.connect()) {
        std::cerr << "Failed to connect to PostgreSQL database\n";
        return 1;
    }
    std::cout << "Connected to PostgreSQL database successfully!\n";

    std::string userInput;
    while (true) {
        std::cout << "Enter a command (type 'exit' to quit): ";
        std::getline(std::cin, userInput);
        if (userInput == "exit") {
            std::cout << "Exiting program." << std::endl;
            break;
        }

        // Handle other commands here
        std::cout << "You entered: " << userInput << std::endl;
    }

    return 0;
}
```

This example simulates an interactive CLI program that waits for user input in a loop. The program will continue running until the user types "exit."

### 3. **Daemon or Server Process**:
If your application is meant to be a long-running process (like a server), you'll typically have it run in a loop handling requests, or simply waiting for incoming connections. For example, in a network-based application, you might have a loop that listens for connections:

```cpp
while (true) {
    // Accept incoming connections, process requests, etc.
}
```

This is a more specific case depending on your application's purpose.

### 4. **Signal Handling**:
You could also implement signal handling to exit gracefully when a termination signal is received. This can be done using the `<csignal>` library in C++. For example:

```cpp
#include <csignal>
#include <iostream>

volatile bool running = true;

void handleSignal(int signal) {
    std::cout << "Signal received: " << signal << ". Terminating program..." << std::endl;
    running = false;
}

int main() {
    signal(SIGINT, handleSignal);  // Handle Ctrl + C (SIGINT)

    // Load config and connect to the database as before
    // ...

    while (running) {
        // Your program logic
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    std::cout << "Program terminated." << std::endl;
    return 0;
}
```

This will allow the program to terminate gracefully when you press `Ctrl + C`.

---

### Conclusion

You can choose any of the above methods depending on how your program is structured or what it will eventually do. For now, the easiest solution is to add a simple infinite loop to keep it running. As you add more functionality, you can replace this with more meaningful loops, like listening for user input or handling network requests.


File: build.sh

#!/bin/zsh

# Root directory check
echo "Creating project folder structure in the current root directory..."

# Create core source code structure
mkdir -p src/{client,networking,file_transfer,serialization,security,database,api/v1,file_transfer,middleware,threads,utils}

# Create client-side folder structure
mkdir -p client_ui

# Create build, include, and lib directories
mkdir -p {build/macos,lib/macos,lib/common,include,tests,scripts,docs,env,config,db/{mongodb,postgresql}}

# Create core C++ files inside the src directories
touch src/main.cpp
touch src/config_manager.h

# Client-side application files
touch src/client/{cli_interface.cpp,client_file_manager.cpp,client_sync_manager.cpp,peer_connection_manager.cpp,client_config_manager.cpp}

# Networking-related files
touch src/networking/{tcp_connection.h,udp_connection.h,peer_discovery.h,network_manager.cpp,peer_tracker.cpp}

# File transfer files
touch src/file_transfer/{file_splitter.h,file_assembler.h,file_verifier.h,file_transfer_manager.cpp,file_chunk_manager.h}

# Serialization files
touch src/serialization/{protobuf_serialization.h,json_serialization.h,serialization_manager.cpp}

# Security files
touch src/security/{encryption_handler.h,decryption_handler.h,key_management.cpp}

# Database files
touch src/database/{postgresql_database.h,mongodb_database.h,database_manager.cpp}

# API structure for versioned APIs
mkdir -p src/api/v1/file
touch src/api/v1/file/{upload_file.h,download_file.h,delete_file.h,file_metadata.h}
touch src/api/v1/peer/{connect_peer.h,disconnect_peer.h,peer_list.h}
touch src/api/v1/security/{auth_middleware.h,login.h,logout.h}
touch src/api/v1/analytics/{activity_log.h,usage_stats.h}

# Middleware files
touch src/middleware/{auth_middleware.h,logging_middleware.h,request_validation.h,rate_limiter.h}

# Threading and concurrency files
touch src/threads/{thread_pool.h,worker_threads.h,thread_manager.cpp}

# Utility files
touch src/utils/{string_helpers.h,file_helpers.h,log_helpers.h}

# Create include headers for the project
touch include/{networking.h,file_transfer.h,api.h,database.h,security.h,middleware.h}

# Create environment files
touch env/.env.development env/.env.staging env/.env.production

# Create configuration files
touch config/{development_config.json,staging_config.json,production_config.json}

# MongoDB and PostgreSQL DB setup scripts
mkdir -p db/mongodb/{users,files}
touch db/mongodb/users/{create_collection.js,seed_data.js,migration_1.js}
touch db/mongodb/files/{create_collection.js,seed_data.js,migration_1.js}
mkdir -p db/postgresql/{users,files}
touch db/postgresql/users/{create_table.sql,seed_data.sql,migration_1.sql}
touch db/postgresql/files/{create_table.sql,seed_data.sql,migration_1.sql}

# Create documentation files
touch docs/architecture.md

# Create CMakeLists.txt
touch CMakeLists.txt

# Create build automation scripts
touch scripts/{build_macos.sh,deploy_macos.sh,common_build.sh}

# Create test files for the system
touch tests/{test_networking.cpp,test_file_transfer.cpp,test_security.cpp,test_database.cpp,test_middleware.cpp,test_client.cpp}

echo "Project structure created successfully."



File: command.md

cd build/macos
cmake ../..
make

./P2PFiledevelopmentSharing --env 



< ----------------- Client Side ------------------- >
< ------------------------------------------------- >
< ----------------- File Upload Process ------------------- >

1. User initiate File Upload Process
2. Look For Available Leechers with available storage
3. Ask the user to choose how much storage of each should be 
4. Create Hash of the file and then store this hash in the 
5. Create a chunk of the file and then store the chunk in the chunk assembly folder
6. Create a file lock mechanism for each chunk
7. Send the chunk to the leechers
8. Once the leecher gets the chunk, then the leecher will send the ack to the seeder
9. Once the seeder gets the ack from all the leechers, then the seeder will send the file to the tracker
- which will include the file name, file size, file hash, file chunks(what are the chunks of the file, means how many chunks are there), file leechers(who are currently downloading the file), file seeders(who are currently uploading the file)
10. Tracker will then update the file status and then send the ack to the seeder
11. Seeder will then send the ack to the user that the file is uploaded successfully
12. Once the file is uploaded successfully, then the user can download the file from the tracker

< ----------------- File Download Process ------------------- >

1. User initiate File Download Process using the tracker and then the tracker will send the file details to the user
2. User will then send the request to the tracker to download the file
3. Tracker will then send the file details to the user
4. User will then send the request to the seeder to download the file
5. Seeder will then send the file to the user
6. User will then send the ack to the seeder
7. Seeder will then send the ack to the tracker
8. Tracker will then send the ack to the user that the file is downloaded successfully




<!-- 4. Then Accordinly break the chunks of the current file into one chunk assembly folder of that file and then once the process is done
4. After that 

    - this process will include chunk naming, adding que adrress to each and then start looking for available leechers(client) and creating multiple tcp connction for each chunk to thier leechers

    - Before sending to each leechers ask for permission rights
    - Based on that create a file lock mechanism
    - Once the file is uploaded to the leecher, then the leecher will send the ack to the seeder
    - Once the seeder gets the ack from all the leechers, then the seeder will send the file to the tracker
    (which will include the file name, file size, file hash, file chunks, file leechers(who are currently downloading the file), file seeders(who are currently uploading the file))
    - Tracker will then update the file status and then send the ack to the seeder
    - Seeder will then send the ack to the user that the file is uploaded successfully

5. Once the file is uploaded successfully, then the user can download the file from the tracker -->


File: development_config.json

{
    "db_host": "localhost",
    "db_port": "5432",
    "db_name": "devdb",
    "db_user": "postgres",
    "db_password": "testbucket8600"
}



File: production_config.json

{
    "db_host": "prod.dbserver.com",
    "db_port": "5432",
    "db_name": "mydb_prod",
    "db_user": "postgres",
    "db_password": "testbucket8600"
}



File: staging_config.json

{
    "db_host": "staging.dbserver.com",
    "db_port": "5432",
    "db_name": "mydb_staging",
    "db_user": "postgres",
    "db_password": "testbucket8600"
}


File: create_collection.js




File: migration_1.js




File: seed_data.js




File: create_collection.js




File: migration_1.js




File: seed_data.js




File: create_table.sql




File: migration_1.sql




File: seed_data.sql




File: create_table.sql




File: migration_1.sql




File: seed_data.sql




File: architecture.md




File: .env.development

ENV=development


File: .env.production

ENV=production


File: .env.staging

ENV=staging


File: api.h




File: database.h




File: file_transfer.h




File: middleware.h




File: networking.h




File: security.h




File: index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFS Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
            background-color: #f4f7fc;
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background-color: #1f2833;
            padding-top: 20px;
            color: #c5c6c7;
        }

        .sidebar h2 {
            text-align: center;
            color: #66fcf1;
            margin-bottom: 30px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar ul li {
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .sidebar ul li:hover {
            background-color: #45a29e;
        }

        .sidebar ul li a {
            color: #c5c6c7;
            text-decoration: none;
            font-size: 18px;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            background-color: #f4f7fc;
            overflow-y: auto;
        }

        .top-bar {
            background-color: #66fcf1;
            color: #1f2833;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .dashboard-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .card {
            background-color: #1f2833;
            color: #c5c6c7;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .upload-btn, .details-btn {
            background-color: #66fcf1;
            color: #1f2833;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .upload-btn:hover, .details-btn:hover {
            background-color: #45a29e;
        }

        .progress-bar {
            background-color: #45a29e;
            width: 0;
            height: 10px;
            border-radius: 5px;
        }

        .progress {
            width: 100%;
            background-color: #c5c6c7;
            height: 10px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        .step-section {
            margin-top: 20px;
        }

        .success-message {
            color: #66fcf1;
            font-size: 14px;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <div class="sidebar" id="sidebar">
        <h2>Dashboard</h2>
        <ul>
            <li><a href="#">Home</a></li>
            <li><a href="#">File Upload</a></li>
            <li><a href="#">Peer Status</a></li>
            <li><a href="#">Network Health</a></li>
            <li><a href="#">Settings</a></li>
        </ul>
    </div>

    <div class="main-content">
        <div class="top-bar">
            <h2>DFS Dashboard</h2>
        </div>

        <div class="dashboard-content">
            <!-- Step 1: Register File -->
            <div class="card step-section">
                <h3>Step 1: Register File</h3>
                <label for="file-name">File Name:</label>
                <input type="text" id="file-name" placeholder="Enter file name">
                <br><br>
                <label for="file-path">File Path:</label>
                <input type="text" id="file-path" placeholder="Enter file path">
                <br><br>
                <button class="upload-btn" onclick="registerFile()">Register File</button>
                <div class="progress hidden" id="register-progress">
                    <div class="progress-bar" id="register-progress-bar"></div>
                </div>
                <div id="register-status" class="success-message"></div>
            </div>

            <!-- Step 2: Seeding Process -->
            <div class="card step-section hidden" id="step-2">
                <h3>Step 2: Tracker Creation & Seeding</h3>
                <button class="upload-btn" onclick="startSeeding()">Start Seeding</button>
                <div class="progress hidden" id="seeding-progress">
                    <div class="progress-bar" id="seeding-progress-bar"></div>
                </div>
                <div id="seeding-status" class="success-message"></div>
            </div>

            <!-- Step 3: Encryption Process (optional) -->
            <div class="card step-section hidden" id="step-3">
                <h3>Step 3: Encryption (Optional)</h3>
                <button class="details-btn" onclick="startEncryption()">Start Encryption</button>
                <div class="progress hidden" id="encryption-progress">
                    <div class="progress-bar" id="encryption-progress-bar"></div>
                </div>
                <div id="encryption-status" class="success-message"></div>
            </div>

            <!-- Step 4: Peer Discovery -->
            <div class="card step-section hidden" id="step-4">
                <h3>Step 4: Peer Discovery</h3>
                <p>Select Network:</p>
                <button class="details-btn" onclick="chooseNetwork('global')">Global Network</button>
                <button class="details-btn" onclick="chooseNetwork('local')">Local Network</button>
                <div id="peer-list" class="hidden"></div>
            </div>

            <!-- Step 5: File Fragmentation -->
            <div class="card step-section hidden" id="step-5">
                <h3>Step 5: File Fragmentation</h3>
                <button class="details-btn" onclick="startFragmentation()">Start Fragmentation</button>
                <div class="progress hidden" id="fragmentation-progress">
                    <div class="progress-bar" id="fragmentation-progress-bar"></div>
                </div>
                <div id="fragmentation-status" class="success-message"></div>
            </div>

            <!-- Step 6: Upload & Hash Verification -->
            <div class="card step-section hidden" id="step-6">
                <h3>Step 6: Upload & Verify</h3>
                <button class="details-btn" onclick="startUpload()">Initiate Upload</button>
                <div class="progress hidden" id="upload-progress">
                    <div class="progress-bar" id="upload-progress-bar"></div>
                </div>
                <div id="upload-status" class="success-message"></div>
            </div>
        </div>
    </div>

    <script>
        function registerFile() {
            document.getElementById('register-progress').classList.remove('hidden');
            let progressBar = document.getElementById('register-progress-bar');
            progressBar.style.width = '0';
            let progress = 0;
            let interval = setInterval(() => {
                progress += 20;
                progressBar.style.width = progress + '%';
                if (progress === 100) {
                    clearInterval(interval);
                    document.getElementById('register-status').innerText = 'File Registered and Tracker Created!';
                    document.getElementById('step-2').classList.remove('hidden'); // Show next step
                }
            }, 500);
        }

        function startSeeding() {
            document.getElementById('seeding-progress').classList.remove('hidden');
            let progressBar = document.getElementById('seeding-progress-bar');
            progressBar.style.width = '0';
            let progress = 0;
            let interval = setInterval(() => {
                progress += 25;
                progressBar.style.width = progress + '%';
                if (progress === 100) {
                    clearInterval(interval);
                    document.getElementById('seeding-status').innerText = 'Seeding Process Complete!';
                    document.getElementById('step-3').classList.remove('hidden'); // Show next step
                }
            }, 600);
        }

        function startEncryption() {
            document.getElementById('encryption-progress').classList.remove('hidden');
            let progressBar = document.getElementById('encryption-progress-bar');
            progressBar.style.width = '0';
            let progress = 0;
            let interval = setInterval(() => {
                progress += 25;
                progressBar.style.width = progress + '%';
                if (progress === 100) {
                    clearInterval(interval);
                    document.getElementById('encryption-status').innerText = 'Encryption Process Complete!';
                    document.getElementById('step-4').classList.remove('hidden'); // Show next step
                }
            }, 700);
        }

        function chooseNetwork(network) {
            document.getElementById('peer-list').classList.remove('hidden');
            // Simulate finding peers based on network choice
            let peers = network === 'global' ? ['Peer 1 (Global)', 'Peer 2 (Global)'] : ['Peer 1 (Local)', 'Peer 2 (Local)'];
            let peerList = document.getElementById('peer-list');
            peerList.innerHTML = ''; // Clear previous entries
            peers.forEach(peer => {
                let peerItem = document.createElement('div');
                peerItem.innerText = peer;
                peerList.appendChild(peerItem);
            });
            document.getElementById('step-5').classList.remove('hidden'); // Show next step
        }

        function startFragmentation() {
            document.getElementById('fragmentation-progress').classList.remove('hidden');
            let progressBar = document.getElementById('fragmentation-progress-bar');
            progressBar.style.width = '0';
            let progress = 0;
            let interval = setInterval(() => {
                progress += 20;
                progressBar.style.width = progress + '%';
                if (progress === 100) {
                    clearInterval(interval);
                    document.getElementById('fragmentation-status').innerText = 'Fragmentation Complete!';
                    document.getElementById('step-6').classList.remove('hidden'); // Show next step
                }
            }, 700);
        }

        function startUpload() {
            document.getElementById('upload-progress').classList.remove('hidden');
            let progressBar = document.getElementById('upload-progress-bar');
            progressBar.style.width = '0';
            let progress = 0;
            let interval = setInterval(() => {
                progress += 15;
                progressBar.style.width = progress + '%';
                if (progress === 100) {
                    clearInterval(interval);
                    document.getElementById('upload-status').innerText = 'Upload Complete! Hash Verified!';
                }
            }, 400);
        }
    </script>
</body>
</html>


File: build_macos.sh




File: common_build.sh




File: deploy_macos.sh




File: delete_file.h




File: download_file.h




File: file_metadata.h




File: upload_file.h




File: cli_interface.cpp




File: client_config_manager.cpp




File: client_file_manager.cpp




File: client_sync_manager.cpp




File: peer_connection_manager.cpp




File: config_manager.h

#ifndef CONFIG_MANAGER_H
#define CONFIG_MANAGER_H

#include <string>
#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>  // Updated include path for nlohmann-json

using json = nlohmann::json;

class ConfigManager {
public:
    bool loadConfig(const std::string& environment) {
        std::string configFile = "../../config/" + environment + "_config.json";
        std::ifstream file(configFile, std::ifstream::binary);
        if (!file.is_open()) {
            std::cerr << "Error: Could not open config file: " << configFile << "\n";
            return false;
        }

        json config;
        file >> config;
        file.close();

        // Load environment-specific settings
        dbHost = config["db_host"].get<std::string>();
        dbPort = config["db_port"].get<std::string>();
        dbName = config["db_name"].get<std::string>();
        dbUser = config["db_user"].get<std::string>();
        dbPassword = config["db_password"].get<std::string>();

        return true;
    }

    // Database configuration
    std::string dbHost;
    std::string dbPort;
    std::string dbName;
    std::string dbUser;
    std::string dbPassword;
};

#endif



File: database_manager.cpp




File: mongodb_database.h




File: postgresql_database.h

// src/database/postgresql_database.h
#ifndef POSTGRESQL_DATABASE_H
#define POSTGRESQL_DATABASE_H

#include <iostream>
#include <pqxx/pqxx> 

class PostgreSQLDatabase {
public:
    PostgreSQLDatabase(const std::string& host, const std::string& port, const std::string& dbname,
                       const std::string& user, const std::string& password)
        : host(host), port(port), dbname(dbname), user(user), password(password) {}

    bool connect() {
        try {
            std::string conn_str = "host=" + host + " port=" + port + " dbname=" + dbname + 
                                   " user=" + user + " password=" + password;
            connection = new pqxx::connection(conn_str);
            if (connection->is_open()) {
                std::cout << "Successfully connected to the database: " << dbname << std::endl;
                return true;
            }
        } catch (const std::exception& e) {
            std::cerr << "Database connection error: " << e.what() << std::endl;
        }
        return false;
    }

    ~PostgreSQLDatabase() {
        // No need to call disconnect, the connection will be closed when the object is destroyed
        if (connection != nullptr && connection->is_open()) {
            std::cout << "Closing connection to the database." << std::endl;
        }
        delete connection;
    }

private:
    std::string host, port, dbname, user, password;
    pqxx::connection* connection = nullptr;
};

#endif



File: file_assembler.h




File: file_chunk_manager.h




File: file_splitter.h




File: file_transfer_manager.cpp




File: file_verifier.h




File: main.cpp

#include <iostream>
#include <thread>   // Required for std::this_thread::sleep_for
#include <chrono>   // Required for std::chrono::seconds
#include "config_manager.h"  // Assuming this includes the database logic
#include "database/postgresql_database.h"

int main(int argc, char** argv) {
    // Load config and connect to the database
    std::string environment = "development";  // Default environment

    // Parse command-line arguments to get the environment
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--env" && i + 1 < argc) {
            environment = argv[++i];
        }
    }

    ConfigManager configManager;
    if (!configManager.loadConfig(environment)) {
        std::cerr << "Failed to load configuration for environment: " << environment << "\n";
        return 1;
    }

    std::cout << "Running in " << environment << " environment." << std::endl;

    PostgreSQLDatabase db(configManager.dbHost, configManager.dbPort, configManager.dbName, configManager.dbUser, configManager.dbPassword);
    if (!db.connect()) {
        std::cerr << "Failed to connect to PostgreSQL database\n";
        return 1;
    }
    std::cout << "Connected to PostgreSQL database successfully!\n";

    // Keep the program running
    while (true) {
        // Simulate program activity or add logic here
        std::this_thread::sleep_for(std::chrono::seconds(1));  // Sleep to prevent high CPU usage
    }

    return 0;
}



File: auth_middleware.h




File: logging_middleware.h




File: rate_limiter.h




File: request_validation.h




File: network_manager.cpp




File: peer_discovery.h




File: peer_tracker.cpp




File: tcp_connection.h




File: udp_connection.h




File: decryption_handler.h




File: encryption_handler.h




File: key_management.cpp




File: json_serialization.h




File: protobuf_serialization.h




File: serialization_manager.cpp




File: thread_manager.cpp




File: thread_pool.h




File: worker_threads.h




File: file_helpers.h




File: log_helpers.h




File: string_helpers.h




File: test.cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> getElements(vector<int> arr, vector<vector<int>> queries) {
    vector<int> result;
    int columns = arr[0]; // Number of columns in each row of the 2D array

    for (const auto& query : queries) {
        int row = query[0] - 1; 
        int col = query[1] - 1; 

        
        int index = row * columns + col + 1; 
        result.push_back(arr[index]);
    }

    return result;
}

int main() {
    // Example usage
    vector<int> arr = {2, 4, 1, 34, 12, -33, 78, 44, 65, -14, -92};
    vector<vector<int>> queries = {{4, 1}, {3, 2}, {5, 1}, {1, 1}};
    
    vector<int> result = getElements(arr, queries);
    for (int val : result) {
        cout << val << endl;
    }

    return 0;
}



File: test.js

const fs = require('fs');
const path = require('path');

/**
 * Recursively reads a directory, generates its tree structure, and retrieves file contents.
 * @param {string} dirPath - The directory path to scan.
 * @param {string} prefix - The prefix for tree indentation.
 * @param {string[]} output - Array to store tree structure as a string.
 * @param {string[]} content - Array to store file content as strings.
 */
function processDirectory(dirPath, prefix = '', output = [], content = []) {
    const stats = fs.statSync(dirPath);

    if (stats.isFile()) {
        const fileName = path.basename(dirPath);
        output.push(`${prefix}├── ${fileName}`);
        
        // Read and store file content
        const fileData = fs.readFileSync(dirPath, 'utf8');
        content.push(`\n\nFile: ${fileName}\n\n${fileData}`);
    } else if (
        stats.isDirectory() && 
        !['.git', 'build'].includes(path.basename(dirPath)) // Exclude .git and build folders
    ) {
        const dirName = path.basename(dirPath);
        output.push(`${prefix}└── ${dirName}`);

        const children = fs.readdirSync(dirPath);

        // Recursively process children
        for (let i = 0; i < children.length; i++) {
            const childPath = path.join(dirPath, children[i]);
            const isLast = i === children.length - 1;
            processDirectory(
                childPath,
                `${prefix}${isLast ? '    ' : '│   '}`,
                output,
                content
            );
        }
    }
}

// The root folder to scan
const ROOT_FOLDER = path.resolve('./');

// Arrays to store tree structure and file contents
const treeOutput = [];
const fileContents = [];

// Generate tree structure and gather file contents
treeOutput.push(path.basename(ROOT_FOLDER));
processDirectory(ROOT_FOLDER, '', treeOutput, fileContents);

// Combine tree structure and file contents
const finalOutput = treeOutput.join('\n') + '\n\n' + fileContents.join('\n');

// Save the combined output to a file
const OUTPUT_FILE = path.join(ROOT_FOLDER, 'directory_with_contents.txt');
fs.writeFileSync(OUTPUT_FILE, finalOutput, 'utf8');

console.log(`Directory tree and file contents saved to ${OUTPUT_FILE}`);



File: test_client.cpp




File: test_database.cpp




File: test_file_transfer.cpp




File: test_middleware.cpp




File: test_networking.cpp




File: test_security.cpp

